#!/usr/bin/env node

/**
 * Git pre-commit hook to check translation completeness
 * Ensures all translation files have matching keys with actual usage in code
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Colors for console output
const colors = {
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    reset: '\x1b[0m',
    bold: '\x1b[1m'
};

function log(message, color = 'reset') {
    console.log(`${colors[color]}${message}${colors.reset}`);
}

function loadJsonFile(filePath) {
    try {
        const content = fs.readFileSync(filePath, 'utf8');
        return JSON.parse(content);
    } catch (error) {
        throw new Error(`Failed to load ${filePath}: ${error.message}`);
    }
}

function getAllKeys(obj, prefix = '') {
    const keys = new Set();

    for (const [key, value] of Object.entries(obj)) {
        const fullKey = prefix ? `${prefix}.${key}` : key;
        keys.add(fullKey);

        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
            const nestedKeys = getAllKeys(value, fullKey);
            nestedKeys.forEach(k => keys.add(k));
        }
    }

    return keys;
}

function checkKeysOrder(obj, filePath, excludeKeys = []) {
    let hasChanges = false;

    function sortObjectKeys(currentObj) {
        const sortedObj = {};
        const keys = Object.keys(currentObj);
        const filteredKeys = keys.filter(key => !excludeKeys.includes(key));
        const excludedKeys = keys.filter(key => excludeKeys.includes(key));

        // Sort filtered keys alphabetically
        const sortedKeys = [...filteredKeys].sort();

        // Add sorted keys first
        for (const key of sortedKeys) {
            if (typeof currentObj[key] === 'object' && currentObj[key] !== null && !Array.isArray(currentObj[key])) {
                const [sortedValue, childHasChanges] = sortObjectKeys(currentObj[key]);
                sortedObj[key] = sortedValue;
                hasChanges = hasChanges || childHasChanges;
            } else {
                sortedObj[key] = currentObj[key];
            }
        }

        // Add excluded keys at the end (maintaining their original order)
        for (const key of excludedKeys) {
            sortedObj[key] = currentObj[key];
        }

        // Check if order changed
        const originalKeys = Object.keys(currentObj);
        const newKeys = Object.keys(sortedObj);
        const orderChanged = originalKeys.some((key, index) => key !== newKeys[index]);

        return [sortedObj, orderChanged];
    }

    const [sortedObj, orderChanged] = sortObjectKeys(obj);
    hasChanges = hasChanges || orderChanged;

    if (hasChanges) {
        try {
            fs.writeFileSync(filePath, JSON.stringify(sortedObj, null, 4) + '\n', 'utf8');
            log(`  🔧 Auto-sorted keys in ${filePath}`, 'blue');
        } catch (error) {
            log(`  ❌ Failed to auto-sort ${filePath}: ${error.message}`, 'red');
            return false;
        }
    }

    return hasChanges;
}

function extractPackageJsonTranslationKeys() {
    const packageJson = loadJsonFile('package.json');
    const requiredKeys = new Set();

    // Extract translation keys from package.json
    function extractFromObject(obj) {
        for (const [key, value] of Object.entries(obj)) {
            if (typeof value === 'string' && value.startsWith('%') && value.endsWith('%')) {
                // Extract key from %key% format
                const translationKey = value.slice(1, -1);
                requiredKeys.add(translationKey);
            } else if (Array.isArray(value)) {
                value.forEach(item => {
                    if (typeof item === 'string' && item.startsWith('%') && item.endsWith('%')) {
                        const translationKey = item.slice(1, -1);
                        requiredKeys.add(translationKey);
                    } else if (typeof item === 'object' && item !== null) {
                        extractFromObject(item);
                    }
                });
            } else if (typeof value === 'object' && value !== null) {
                extractFromObject(value);
            }
        }
    }

    extractFromObject(packageJson);
    return requiredKeys;
}

function findFilesRecursively(dir, extensions = []) {
    const files = [];

    function walkDir(currentDir) {
        try {
            const items = fs.readdirSync(currentDir);

            for (const item of items) {
                const fullPath = path.join(currentDir, item);
                const stat = fs.statSync(fullPath);

                if (stat.isDirectory()) {
                    // Skip node_modules and other common directories
                    if (!['node_modules', '.git', 'dist', 'out'].includes(item)) {
                        walkDir(fullPath);
                    }
                } else if (stat.isFile()) {
                    const ext = path.extname(fullPath).slice(1);
                    if (extensions.length === 0 || extensions.includes(ext)) {
                        files.push(fullPath);
                    }
                }
            }
        } catch (error) {
            // Ignore directories we can't read
        }
    }

    if (fs.existsSync(dir)) {
        walkDir(dir);
    }

    return files;
}

function extractVSCodeL10nCalls() {
    const requiredKeys = new Set();

    try {
        // Find all TypeScript and JavaScript files in src directory
        const files = findFilesRecursively('src', ['ts', 'js']);

        for (const file of files) {
            try {
                const content = fs.readFileSync(file, 'utf8');

                // Match vscode.l10n.t('key') or vscode.l10n.t("key")
                const matches = content.match(/vscode\.l10n\.t\s*\(\s*['"](.*?)['"]/g);
                if (matches) {
                    matches.forEach(match => {
                        const keyMatch = match.match(/vscode\.l10n\.t\s*\(\s*['"]([^'"]*)['"]/);
                        if (keyMatch) {
                            requiredKeys.add(keyMatch[1]);
                        }
                    });
                }
            } catch (error) {
                // Ignore errors for individual files
            }
        }
    } catch (error) {
        log(`Warning: Failed to extract vscode.l10n.t calls: ${error.message}`, 'yellow');
    }

    return requiredKeys;
}

function extractWebviewTranslationCalls() {
    const requiredKeys = new Set();

    try {
        // Find all TypeScript and TSX files in webview directory
        const webviewDir = path.join('src', 'webview');
        const files = findFilesRecursively(webviewDir, ['tsx', 'ts']);

        for (const file of files) {
            try {
                const content = fs.readFileSync(file, 'utf8');

                // Match t('key') or t("key")
                const matches = content.match(/\bt\s*\(\s*['"](.*?)['"]/g);
                if (matches) {
                    matches.forEach(match => {
                        const keyMatch = match.match(/\bt\s*\(\s*['"]([^'"]*)['"]/);
                        if (keyMatch) {
                            requiredKeys.add(keyMatch[1]);
                        }
                    });
                }
            } catch (error) {
                // Ignore errors for individual files
            }
        }
    } catch (error) {
        log(`Warning: Failed to extract webview t() calls: ${error.message}`, 'yellow');
    }

    return requiredKeys;
}

function checkPackageJsonTranslations() {
    log(`\n${colors.bold}Checking VSCode Extension Configuration Translations...${colors.reset}`);

    let hasErrors = false;

    try {
        // Get required keys from package.json
        const requiredKeys = extractPackageJsonTranslationKeys();
        log(`Required translation keys from package.json: ${requiredKeys.size}`);

        // Check English translations
        const englishData = loadJsonFile('package.nls.json');
        const englishKeys = getAllKeys(englishData);
        log(`English translations (package.nls.json): ${englishKeys.size} keys`);

        // Check Chinese translations
        const chineseData = loadJsonFile('package.nls.zh.json');
        const chineseKeys = getAllKeys(chineseData);
        log(`Chinese translations (package.nls.zh.json): ${chineseKeys.size} keys`);

        // Auto-sort keys
        const englishSorted = checkKeysOrder(englishData, 'package.nls.json');
        const chineseSorted = checkKeysOrder(chineseData, 'package.nls.zh.json');

        if (englishSorted || chineseSorted) {
            log(`  ℹ️  Files were automatically sorted and will be included in commit`, 'blue');
        }

        // Check missing keys in English
        const missingInEnglish = [...requiredKeys].filter(key => !englishKeys.has(key));
        if (missingInEnglish.length > 0) {
            hasErrors = true;
            log(`  ❌ Missing keys in package.nls.json:`, 'red');
            missingInEnglish.forEach(key => log(`    - ${key}`, 'red'));
        }

        // Check missing keys in Chinese
        const missingInChinese = [...requiredKeys].filter(key => !chineseKeys.has(key));
        if (missingInChinese.length > 0) {
            hasErrors = true;
            log(`  ❌ Missing keys in package.nls.zh.json:`, 'red');
            missingInChinese.forEach(key => log(`    - ${key}`, 'red'));
        }

        // Check extra keys in English (now fatal error)
        const extraInEnglish = [...englishKeys].filter(key => !requiredKeys.has(key));
        if (extraInEnglish.length > 0) {
            hasErrors = true;
            log(`  ❌ Extra keys in package.nls.json (not used in package.json):`, 'red');
            extraInEnglish.forEach(key => log(`    - ${key}`, 'red'));
        }

        // Check extra keys in Chinese (now fatal error)
        const extraInChinese = [...chineseKeys].filter(key => !requiredKeys.has(key));
        if (extraInChinese.length > 0) {
            hasErrors = true;
            log(`  ❌ Extra keys in package.nls.zh.json (not used in package.json):`, 'red');
            extraInChinese.forEach(key => log(`    - ${key}`, 'red'));
        }

        if (!hasErrors) {
            log(`  ✅ Package.json translations are complete`, 'green');
        }

    } catch (error) {
        hasErrors = true;
        log(`❌ Error checking package.json translations: ${error.message}`, 'red');
    }

    return hasErrors;
}

function checkBundleTranslations() {
    log(`\n${colors.bold}Checking VSCode Extension Runtime Bundle Translations...${colors.reset}`);

    let hasErrors = false;

    try {
        // Get required keys from vscode.l10n.t calls
        const requiredKeys = extractVSCodeL10nCalls();
        log(`Required translation keys from vscode.l10n.t calls: ${requiredKeys.size}`);

        // Check Chinese bundle translations
        const bundleData = loadJsonFile('l10n/bundle.l10n.zh-cn.json');
        const bundleKeys = new Set(Object.keys(bundleData));
        log(`Bundle translations (l10n/bundle.l10n.zh-cn.json): ${bundleKeys.size} keys`);

        // Load whitelist from bundle file if it exists
        const whitelist = new Set();
        if (bundleData['__WHITELIST__']) {
            if (Array.isArray(bundleData['__WHITELIST__'])) {
                bundleData['__WHITELIST__'].forEach(key => whitelist.add(key));
                log(`Whitelist found: ${whitelist.size} allowed extra keys`);
            } else {
                log(`  ⚠️  __WHITELIST__ should be an array, ignoring...`, 'yellow');
            }
            // Remove whitelist from bundle keys for normal checking
            bundleKeys.delete('__WHITELIST__');
        }

        // Auto-sort keys (exclude __WHITELIST__ from ordering)
        const bundleSorted = checkKeysOrder(bundleData, 'l10n/bundle.l10n.zh-cn.json', ['__WHITELIST__']);

        if (bundleSorted) {
            log(`  ℹ️  Bundle file was automatically sorted and will be included in commit`, 'blue');
        }

        // Check missing keys in bundle
        const missingInBundle = [...requiredKeys].filter(key => !bundleKeys.has(key));
        if (missingInBundle.length > 0) {
            hasErrors = true;
            log(`  ❌ Missing keys in l10n/bundle.l10n.zh-cn.json:`, 'red');
            missingInBundle.forEach(key => log(`    - ${key}`, 'red'));
        }

        // Check extra keys in bundle (now fatal error, excluding whitelisted ones)
        const extraInBundle = [...bundleKeys].filter(key => !requiredKeys.has(key) && !whitelist.has(key));
        if (extraInBundle.length > 0) {
            hasErrors = true;
            log(`  ❌ Extra keys in l10n/bundle.l10n.zh-cn.json (not used in code and not whitelisted):`, 'red');
            extraInBundle.forEach(key => log(`    - ${key}`, 'red'));
        }

        // Show whitelisted keys that are present
        const whitelistedPresent = [...whitelist].filter(key => bundleKeys.has(key));
        if (whitelistedPresent.length > 0) {
            log(`  ℹ️  Whitelisted keys present in bundle:`, 'blue');
            whitelistedPresent.forEach(key => log(`    - ${key}`, 'blue'));
        }

        if (!hasErrors) {
            log(`  ✅ Bundle translations are complete`, 'green');
        }

    } catch (error) {
        hasErrors = true;
        log(`❌ Error checking bundle translations: ${error.message}`, 'red');
    }

    return hasErrors;
}

function checkWebviewTranslations() {
    log(`\n${colors.bold}Checking React Webview Translations...${colors.reset}`);

    let hasErrors = false;

    try {
        // Get required keys from t() calls
        const requiredKeys = extractWebviewTranslationCalls();
        log(`Required translation keys from t() calls: ${requiredKeys.size}`);

        // Check English translations
        const englishData = loadJsonFile('src/webview/l10n/en.json');
        const englishKeys = new Set(Object.keys(englishData));
        log(`English translations (src/webview/l10n/en.json): ${englishKeys.size} keys`);

        // Check Chinese translations
        const chineseData = loadJsonFile('src/webview/l10n/zh.json');
        const chineseKeys = new Set(Object.keys(chineseData));
        log(`Chinese translations (src/webview/l10n/zh.json): ${chineseKeys.size} keys`);

        // Auto-sort keys
        const englishSorted = checkKeysOrder(englishData, 'src/webview/l10n/en.json');
        const chineseSorted = checkKeysOrder(chineseData, 'src/webview/l10n/zh.json');

        if (englishSorted || chineseSorted) {
            log(`  ℹ️  Webview translation files were automatically sorted and will be included in commit`, 'blue');
        }

        // Check missing keys in English
        const missingInEnglish = [...requiredKeys].filter(key => !englishKeys.has(key));
        if (missingInEnglish.length > 0) {
            hasErrors = true;
            log(`  ❌ Missing keys in src/webview/l10n/en.json:`, 'red');
            missingInEnglish.forEach(key => log(`    - ${key}`, 'red'));
        }

        // Check missing keys in Chinese
        const missingInChinese = [...requiredKeys].filter(key => !chineseKeys.has(key));
        if (missingInChinese.length > 0) {
            hasErrors = true;
            log(`  ❌ Missing keys in src/webview/l10n/zh.json:`, 'red');
            missingInChinese.forEach(key => log(`    - ${key}`, 'red'));
        }

        // Check extra keys in English (now fatal error)
        const extraInEnglish = [...englishKeys].filter(key => !requiredKeys.has(key));
        if (extraInEnglish.length > 0) {
            hasErrors = true;
            log(`  ❌ Extra keys in src/webview/l10n/en.json (not used in code):`, 'red');
            extraInEnglish.forEach(key => log(`    - ${key}`, 'red'));
        }

        // Check extra keys in Chinese (now fatal error)
        const extraInChinese = [...chineseKeys].filter(key => !requiredKeys.has(key));
        if (extraInChinese.length > 0) {
            hasErrors = true;
            log(`  ❌ Extra keys in src/webview/l10n/zh.json (not used in code):`, 'red');
            extraInChinese.forEach(key => log(`    - ${key}`, 'red'));
        }

        if (!hasErrors) {
            log(`  ✅ Webview translations are complete`, 'green');
        }

    } catch (error) {
        hasErrors = true;
        log(`❌ Error checking webview translations: ${error.message}`, 'red');
    }

    return hasErrors;
}

function main() {
    log(`${colors.bold}${colors.blue}🔍 Checking translation completeness and auto-sorting...${colors.reset}`);

    let hasAnyErrors = false;
    let hasAutoSorted = false;

    // Check package.json translations
    const packageErrors = checkPackageJsonTranslations();
    hasAnyErrors = hasAnyErrors || packageErrors;

    // Check bundle translations
    const bundleErrors = checkBundleTranslations();
    hasAnyErrors = hasAnyErrors || bundleErrors;

    // Check webview translations
    const webviewErrors = checkWebviewTranslations();
    hasAnyErrors = hasAnyErrors || webviewErrors;

    // If files were auto-sorted, add them to git staging
    const filesToCheck = [
        'package.nls.json',
        'package.nls.zh.json',
        'l10n/bundle.l10n.zh-cn.json',
        'src/webview/l10n/en.json',
        'src/webview/l10n/zh.json'
    ];

    for (const file of filesToCheck) {
        try {
            // Check if file was modified (simple timestamp check would be better, but this works)
            const status = execSync(`git status --porcelain "${file}"`, { encoding: 'utf8', stdio: 'pipe' }).trim();
            if (status && status.includes('M ')) {
                execSync(`git add "${file}"`, { stdio: 'pipe' });
                hasAutoSorted = true;
            }
        } catch (error) {
            // Ignore git errors - file might not be tracked yet
        }
    }

    if (hasAutoSorted) {
        log('\n🔧 Auto-sorted files have been added to the commit', 'blue');
    }

    // Summary
    log('\n' + '='.repeat(50));
    if (hasAnyErrors) {
        log('❌ Translation check failed! Please fix the issues above.', 'red');
        log('Commit aborted.', 'red');
        process.exit(1);
    } else {
        log('✅ All translations are complete!', 'green');
        if (hasAutoSorted) {
            log('🔧 Files were automatically sorted and included in commit', 'blue');
        }
        log('Proceeding with commit...', 'green');
        process.exit(0);
    }
}

// Only run if executed as main script
if (require.main === module) {
    main();
}
